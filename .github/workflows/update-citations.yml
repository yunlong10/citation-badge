name: Update Citations

on:
  schedule:
    - cron: "0 */12 * * *"
  workflow_dispatch:

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install requests
        run: pip install requests

      - name: Fetch citation count from SerpAPI and update JSONs
        env:
          SERPAPI_API_KEY: ${{ secrets.SERPAPI_API_KEY }}
        run: |
          python <<'EOF'
          import requests, json, re, traceback

          api_key = "${{ secrets.SERPAPI_API_KEY }}"
          user_id = "xf1rCgoAAAAJ"

          def log(*a):
              print("[update-citations]", *a)

          # 1) Read papers.bib to collect google_scholar_id (check main/master branch)
          bib_url = "https://raw.githubusercontent.com/yunlong10/yunlong10.github.io/master/_bibliography/papers.bib"
          allowed_ids = set()
          try:
              r = requests.get(bib_url, timeout=30)
              r.raise_for_status()
              content = r.text
              for m in re.finditer(r'google_scholar_id\s*=\s*\{([^}]+)\}', content):
                  allowed_ids.add(m.group(1).strip())
              log("allowed_ids from papers.bib:", sorted(allowed_ids))
          except Exception as e:
              log("ERROR fetching papers.bib:", e)
              traceback.print_exc()

          # 2) Fetch SerpAPI author data (with pagination to get all articles)
          articles = []
          page = 0
          while True:
              url = f"https://serpapi.com/search.json?engine=google_scholar_author&author_id={user_id}&api_key={api_key}&start={page * 20}"
              res = requests.get(url, timeout=30)
              res.raise_for_status()
              data = res.json()
              
              page_articles = data.get("articles", []) or []
              if not page_articles:
                  break
              articles.extend(page_articles)
              
              # Check if there are more pages
              pagination = data.get("serpapi_pagination", {})
              if not pagination.get("next"):
                  break
              page += 1
              
              # Safety limit: don't fetch more than 10 pages (200 articles)
              if page >= 10:
                  break

          log("serpapi articles count:", len(articles))
          if articles:
              sample = articles[0]
              log("sample.keys:", list(sample.keys()))
              log("sample.link:", sample.get("link"))
              log("sample.result_id:", sample.get("result_id"))
              log("sample.cited_by:", sample.get("cited_by"))

          # 3) Total citations (from first page)
          try:
              total = data["cited_by"]["table"][0]["citations"]["all"]
          except Exception:
              total = 0
          with open('citations.json', 'w') as f:
              json.dump({"schemaVersion": 1, "label": "Citations", "message": str(total), "color": "blue"}, f, indent=2)
          log("wrote citations.json total:", total)

          # 4) Build a map of article_id -> citation_count from SerpAPI response
          per_article_from_api = {}
          for a in articles:
              article_id = None
              link = (a.get("link") or "")
              m = re.search(r'citation_for_view=[^:]+:([^&]+)', link)
              if m:
                  article_id = m.group(1)
              else:
                  rid = (a.get("result_id") or "")
                  m2 = re.search(r'^[^:]+:([^:]+)$', rid)
                  article_id = m2.group(1) if m2 else None

              cb = a.get("cited_by")
              cited = cb.get("value") if isinstance(cb, dict) else None

              if article_id and isinstance(cited, int):
                  per_article_from_api[article_id] = cited

          log("extracted article_ids from API:", sorted(per_article_from_api.keys()))

          # 5) For each allowed_id, get citation count (from API response or query directly)
          per_article = {}
          if allowed_ids:
              for article_id in allowed_ids:
                  if article_id in per_article_from_api:
                      # Found in API response
                      per_article[article_id] = per_article_from_api[article_id]
                      log(f"Found {article_id} in API response: {per_article[article_id]} citations")
                  else:
                      # Not found in API response, try to query directly using view_citation
                      log(f"Article {article_id} not found in API response, querying directly...")
                      try:
                          # Use view_citation to get the article's citation info
                          query_url = f"https://serpapi.com/search.json?engine=google_scholar&view_op=view_citation&citation_id={user_id}:{article_id}&api_key={api_key}"
                          query_res = requests.get(query_url, timeout=30)
                          query_res.raise_for_status()
                          query_data = query_res.json()
                          
                          # Try to extract citation count from the query result
                          cited_count = None
                          
                          # Check for citation info in various possible locations
                          if "citation" in query_data:
                              citation_info = query_data["citation"]
                              if isinstance(citation_info, dict):
                                  if "cited_by" in citation_info:
                                      cited_by_info = citation_info["cited_by"]
                                      if isinstance(cited_by_info, dict) and "value" in cited_by_info:
                                          cited_count = cited_by_info["value"]
                                  elif "cited_by" in citation_info and isinstance(citation_info["cited_by"], int):
                                      cited_count = citation_info["cited_by"]
                          
                          # Also check top-level cited_by
                          if cited_count is None and "cited_by" in query_data:
                              cited_by_info = query_data["cited_by"]
                              if isinstance(cited_by_info, dict) and "value" in cited_by_info:
                                  cited_count = cited_by_info["value"]
                              elif isinstance(cited_by_info, int):
                                  cited_count = cited_by_info
                          
                          if cited_count is not None and isinstance(cited_count, int):
                              per_article[article_id] = cited_count
                              log(f"Queried {article_id} directly: {cited_count} citations")
                          else:
                              log(f"Could not get citation count for {article_id} from direct query, will skip")
                              log(f"Query response keys: {list(query_data.keys())}")
                      except Exception as e:
                          log(f"Error querying {article_id} directly: {e}")
                          traceback.print_exc()
              
              log("filtered article_ids:", sorted(per_article.keys()))
          else:
              log("allowed_ids empty -> fallback to all extracted articles (temporary)")
              per_article = per_article_from_api

          with open('per_article_citations.json', 'w') as f:
              json.dump(per_article, f, indent=2)
          log("wrote per_article_citations.json with", len(per_article), "items")
          EOF

      - name: Commit and push changes
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add citations.json per_article_citations.json
          git commit -m "Update citation counts (total + per-article, papers.bib filtered with fallback)" || echo "No changes to commit"
          git push
